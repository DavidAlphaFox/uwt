<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Uwt.Tty.html">
<link rel="next" href="Uwt.Timer.html">
<link rel="Up" href="Uwt.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uv_fs_sync" rel="Chapter" href="Uv_fs_sync.html">
<link title="Uwt" rel="Chapter" href="Uwt.html">
<link title="Uwt_base" rel="Chapter" href="Uwt_base.html">
<link title="Uwt_bytes" rel="Chapter" href="Uwt_bytes.html">
<link title="Uwt_chan" rel="Chapter" href="Uwt_chan.html">
<link title="Uwt_compat" rel="Chapter" href="Uwt_compat.html">
<link title="Uwt_io" rel="Chapter" href="Uwt_io.html">
<link title="Uwt_log" rel="Chapter" href="Uwt_log.html">
<link title="Uwt_preemptive" rel="Chapter" href="Uwt_preemptive.html">
<link title="Uwt_process" rel="Chapter" href="Uwt_process.html">
<link title="Uwt_throttle" rel="Chapter" href="Uwt_throttle.html">
<link title="Uwt_timeout" rel="Chapter" href="Uwt_timeout.html"><title>Uwt - OCaml bindings for libuv : Uwt.Pipe</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Uwt.Tty.html" title="Uwt.Tty">Previous</a>
&nbsp;<a class="up" href="Uwt.html" title="Uwt">Up</a>
&nbsp;<a class="post" href="Uwt.Timer.html" title="Uwt.Timer">Next</a>
</div>
<h1>Module <a href="type_Uwt.Pipe.html">Uwt.Pipe</a></h1>

<pre><span class="keyword">module</span> Pipe: <code class="code">sig</code> <a href="Uwt.Pipe.html">..</a> <code class="code">end</code></pre><hr width="100%">
<br>
Pipe handles provide an abstraction over local domain sockets on
      Unix and named pipes on Windows.<br>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> </pre>


<pre><span class="keyword">include</span> <a href="Uwt.Stream.html">Uwt.Stream</a></pre>

<pre><span class="keyword">include</span> <a href="Uwt.Handle_ext.html">Uwt.Handle_ext</a></pre>

<pre><span class="keyword">include</span> <a href="Uwt.Handle_fileno.html">Uwt.Handle_fileno</a></pre>

<pre><span id="VALto_stream"><span class="keyword">val</span> to_stream</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> <a href="Uwt.Stream.html#TYPEt">Uwt.Stream.t</a></code></pre>
<pre><span id="VALinit"><span class="keyword">val</span> init</span> : <code class="type">?ipc:bool -> unit -> <a href="Uwt.Pipe.html#TYPEt">t</a></code></pre><div class="info ">
The only thing that can go wrong, is memory allocation.
      In this case the ordinary exception <code class="code">Out_of_memory</code> is thrown.
      The function is not called init_exn, because this exception can
      be thrown by nearly all functions.<br>
</div>
<div class="param_info"><code class="code">ipc</code> : is false by default</div>

<pre><span id="VALopenpipe"><span class="keyword">val</span> openpipe</span> : <code class="type">?ipc:bool -> Unix.file_descr -> <a href="Uwt.Pipe.html#TYPEt">t</a> uv_result</code></pre><div class="info ">
Be careful with open* functions. They exists, so you can re-use
     system dependent libraries. But if you pass a file descriptor
     to openpipe (or opentcp,...), that is not really a file descriptor of a
     pipe (or tcp socket,...) you can trigger assert failures inside libuv.<br>
</div>
<div class="param_info"><code class="code">ipc</code> : is false by default</div>

<pre><span id="VALopenpipe_exn"><span class="keyword">val</span> openpipe_exn</span> : <code class="type">?ipc:bool -> Unix.file_descr -> <a href="Uwt.Pipe.html#TYPEt">t</a></code></pre>
<pre><span id="VALbind"><span class="keyword">val</span> bind</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> path:string -> Int_result.unit</code></pre><div class="info ">
Bind the pipe to a file path (Unix) or a name (Windows).<br>
</div>

<pre><span id="VALbind_exn"><span class="keyword">val</span> bind_exn</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> path:string -> unit</code></pre>
<pre><span id="VALgetsockname"><span class="keyword">val</span> getsockname</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> string uv_result</code></pre><div class="info ">
Get the name of the Unix domain socket or the named pipe.<br>
</div>

<pre><span id="VALgetsockname_exn"><span class="keyword">val</span> getsockname_exn</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> string</code></pre>
<pre><span id="VALgetpeername"><span class="keyword">val</span> getpeername</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> string uv_result</code></pre><div class="info ">
Get the name of the Unix domain socket or the named pipe to
      which the handle is connected.<br>
</div>

<pre><span id="VALgetpeername_exn"><span class="keyword">val</span> getpeername_exn</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> string</code></pre>
<pre><span id="VALpending_instances"><span class="keyword">val</span> pending_instances</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> int -> Int_result.unit</code></pre><div class="info ">
Set the number of pending pipe instance handles when the pipe
      server is waiting for connections.
<p>

      Note: This setting applies to Windows only.<br>
</div>

<pre><span id="VALpending_instances_exn"><span class="keyword">val</span> pending_instances_exn</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> int -> unit</code></pre>
<pre><span id="VALaccept"><span class="keyword">val</span> accept</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> <a href="Uwt.Pipe.html#TYPEt">t</a> uv_result</code></pre><div class="info ">
initializes a new client, accepts and returns it.
<p>

      This call is used in conjunction with <code class="code">listen</code> to accept
      incoming connections. Call this function after receiving a
      <code class="code">listen</code> callback to accept the connection.
<p>

      When the <code class="code">listen</code> callback is called it is guaranteed
      that this function will complete successfully the first time. If
      you attempt to use it more than once, it may fail. It is
      suggested to only call this function once per <code class="code">listen</code> callback
      call.
<p>

      Don't use this function for pipes that have been initialized with
      <code class="code">~ipc:true</code>. It's not portable.<br>
</div>

<pre><span id="VALaccept_exn"><span class="keyword">val</span> accept_exn</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> <a href="Uwt.Pipe.html#TYPEt">t</a></code></pre>
<pre><span id="VALaccept_raw"><span class="keyword">val</span> accept_raw</span> : <code class="type">server:<a href="Uwt.Pipe.html#TYPEt">t</a> -> client:<a href="Uwt.Pipe.html#TYPEt">t</a> -> Int_result.unit</code></pre>
<pre><span id="VALaccept_raw_exn"><span class="keyword">val</span> accept_raw_exn</span> : <code class="type">server:<a href="Uwt.Pipe.html#TYPEt">t</a> -> client:<a href="Uwt.Pipe.html#TYPEt">t</a> -> unit</code></pre>
<pre><span id="VALpending_count"><span class="keyword">val</span> pending_count</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> Int_result.int</code></pre>
<pre><span id="VALpending_count_exn"><span class="keyword">val</span> pending_count_exn</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> int</code></pre><div class="info ">
how many handles are waiting to be accepted with <a href="Uwt.Pipe.html#VALaccept_ipc"><code class="code">Uwt.Pipe.accept_ipc</code></a><br>
</div>

<pre><code><span id="TYPEipc_result"><span class="keyword">type</span> <code class="type"></code>ipc_result</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTipc_result.Ipc_error"><span class="constructor">Ipc_error</span></span> <span class="keyword">of</span> <code class="type">error</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
internal call to accept failed<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTipc_result.Ipc_none"><span class="constructor">Ipc_none</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
no pending handles<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTipc_result.Ipc_tcp"><span class="constructor">Ipc_tcp</span></span> <span class="keyword">of</span> <code class="type"><a href="Uwt.Tcp.html#TYPEt">Uwt.Tcp.t</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTipc_result.Ipc_udp"><span class="constructor">Ipc_udp</span></span> <span class="keyword">of</span> <code class="type"><a href="Uwt.Udp.html#TYPEt">Uwt.Udp.t</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTipc_result.Ipc_pipe"><span class="constructor">Ipc_pipe</span></span> <span class="keyword">of</span> <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a></code></code></td>

</tr></table>



<pre><span id="VALaccept_ipc"><span class="keyword">val</span> accept_ipc</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> <a href="Uwt.Pipe.html#TYPEipc_result">ipc_result</a></code></pre><div class="info ">
Used to receive handles over IPC pipes.
<p>

      It call's <a href="Uwt.Pipe.html#VALpending_count"><code class="code">Uwt.Pipe.pending_count</code></a>, if it's &gt; 0 then it initializes a
      handle of the appropriate type, accepts and returns it<br>
</div>

<pre><span id="VALwrite2"><span class="keyword">val</span> write2</span> : <code class="type">?pos:int -><br>       ?len:int -> buf:bytes -> send:<a href="Uwt.Tcp.html#TYPEt">Uwt.Tcp.t</a> -> <a href="Uwt.Pipe.html#TYPEt">t</a> -> unit Lwt.t</code></pre><div class="info ">
Extended write function for sending handles over a pipe. The
      pipe must be initialized with <code class="code">~ipc:true</code>.
<p>

      Note: send_handle must be a TCP socket or pipe, which is a server
      or a connection (listening or connected state). Bound sockets or
      pipes will be assumed to be servers.<br>
</div>

<pre><span id="VALwrite2_ba"><span class="keyword">val</span> write2_ba</span> : <code class="type">?pos:int -> ?len:int -> buf:buf -> send:<a href="Uwt.Tcp.html#TYPEt">Uwt.Tcp.t</a> -> <a href="Uwt.Pipe.html#TYPEt">t</a> -> unit Lwt.t</code></pre>
<pre><span id="VALwrite2_string"><span class="keyword">val</span> write2_string</span> : <code class="type">?pos:int -><br>       ?len:int -> buf:string -> send:<a href="Uwt.Tcp.html#TYPEt">Uwt.Tcp.t</a> -> <a href="Uwt.Pipe.html#TYPEt">t</a> -> unit Lwt.t</code></pre>
<pre><span id="VALwrite2_pipe"><span class="keyword">val</span> write2_pipe</span> : <code class="type">?pos:int -><br>       ?len:int -> buf:bytes -> send:<a href="Uwt.Pipe.html#TYPEt">t</a> -> <a href="Uwt.Pipe.html#TYPEt">t</a> -> unit Lwt.t</code></pre><div class="info ">
Similar to <a href="Uwt.Pipe.html#VALwrite2"><code class="code">Uwt.Pipe.write2</code></a>, but the send handle is a pipe.
      Note: This is not supported on Windows<br>
</div>

<pre><span id="VALwrite2_pipe_ba"><span class="keyword">val</span> write2_pipe_ba</span> : <code class="type">?pos:int -><br>       ?len:int -> buf:buf -> send:<a href="Uwt.Pipe.html#TYPEt">t</a> -> <a href="Uwt.Pipe.html#TYPEt">t</a> -> unit Lwt.t</code></pre>
<pre><span id="VALwrite2_pipe_string"><span class="keyword">val</span> write2_pipe_string</span> : <code class="type">?pos:int -><br>       ?len:int -> buf:string -> send:<a href="Uwt.Pipe.html#TYPEt">t</a> -> <a href="Uwt.Pipe.html#TYPEt">t</a> -> unit Lwt.t</code></pre>
<pre><span id="VALwrite2_udp"><span class="keyword">val</span> write2_udp</span> : <code class="type">?pos:int -><br>       ?len:int -> buf:bytes -> send:<a href="Uwt.Udp.html#TYPEt">Uwt.Udp.t</a> -> <a href="Uwt.Pipe.html#TYPEt">t</a> -> unit Lwt.t</code></pre><div class="info ">
Similar to <a href="Uwt.Pipe.html#VALwrite2"><code class="code">Uwt.Pipe.write2</code></a>, but the send handle is an udp socket.
      Note: This is not portable at all<br>
</div>

<pre><span id="VALwrite2_udp_ba"><span class="keyword">val</span> write2_udp_ba</span> : <code class="type">?pos:int -> ?len:int -> buf:buf -> send:<a href="Uwt.Udp.html#TYPEt">Uwt.Udp.t</a> -> <a href="Uwt.Pipe.html#TYPEt">t</a> -> unit Lwt.t</code></pre>
<pre><span id="VALwrite2_udp_string"><span class="keyword">val</span> write2_udp_string</span> : <code class="type">?pos:int -><br>       ?len:int -> buf:string -> send:<a href="Uwt.Udp.html#TYPEt">Uwt.Udp.t</a> -> <a href="Uwt.Pipe.html#TYPEt">t</a> -> unit Lwt.t</code></pre>
<pre><span id="VALconnect"><span class="keyword">val</span> connect</span> : <code class="type"><a href="Uwt.Pipe.html#TYPEt">t</a> -> path:string -> unit Lwt.t</code></pre><div class="info ">
Connect to the Unix domain socket or the named pipe.<br>
</div>

<pre><span id="VALwith_pipe"><span class="keyword">val</span> with_pipe</span> : <code class="type">?ipc:bool -> (<a href="Uwt.Pipe.html#TYPEt">t</a> -> 'a Lwt.t) -> 'a Lwt.t</code></pre><div class="info ">
<code class="code">with_pipe ?ipc f</code> creates a new handle and passes
      the pipe to <code class="code">f</code>. It is ensured that the pipe is closed when <code class="code">f t</code>
      terminates (even if it fails).
<p>

      You can also close the pipe manually inside <code class="code">f</code> without further
      consequences.<br>
</div>

<pre><span id="VALwith_connect"><span class="keyword">val</span> with_connect</span> : <code class="type">path:string -> (<a href="Uwt.Pipe.html#TYPEt">t</a> -> 'a Lwt.t) -> 'a Lwt.t</code></pre>
<pre><span id="VALwith_open"><span class="keyword">val</span> with_open</span> : <code class="type">?ipc:bool -> Unix.file_descr -> (<a href="Uwt.Pipe.html#TYPEt">t</a> -> 'a Lwt.t) -> 'a Lwt.t</code></pre></body></html>