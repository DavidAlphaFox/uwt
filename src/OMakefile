.DEFAULT: lib
.PHONY: clean all distclean doc lib

CC= $(OCAMLC_CC)
CFLAGS= $(OCAMLC_CC_CFLAGS) $(CFLAGS)

if $(equal $(OSTYPE),Win32)
	configure config.h.in: configure.ac
		if $(or $(not $(file-exists configure)),$(not $(file-exists config.h.in)))
			bash.exe autoreconf -fi
		else
			touch configure config.h.in
	config.h: config.h.in configure
		bash.exe configure CC="$(OCAMLC_CC)" CFLAGS="$(CFLAGS) $(CFLAGS_LIBUV)"  LDFLAGS="$(LDFLAGS_LIBUV)"
else
	configure config.h.in: configure.ac
		if $(or $(not $(file-exists configure)),$(not $(file-exists config.h.in)))
			autoreconf -fi
		else
			touch configure config.h.in
	config.h: config.h.in configure
		./configure CC="$(OCAMLC_CC)" CFLAGS="$(CFLAGS) $(CFLAGS_LIBUV)"  LDFLAGS="$(LDFLAGS_LIBUV)"

clean::
	rm -f config.log config.status

distclean::
	rm -f config.h *~ configure
	rm -rf autom4te.cache

section
	.SCANNER: scan-c-%: config.h
	CFILES= emap_gen
	CFLAGS= $(CFLAGS) $(CFLAGS_LIBUV)
	LDFLAGS+= $(LDFLAGS_LIBUV)
	Repeat_ctargets($(CFILES))
	T=$(CProgram emap_gen, $(CFILES))
	clean::
		rm -f emap_gen$(EXE)
	distclean::
		rm -f error.ml error_val.ml error_val.mli map_error.h
	error.ml error_val.ml map_error.h: emap_gen$(EXE)
		if $(or $(not $(file-exists error.ml)),$(or $(not $(file-exists error_val.ml)), $(not $(file-exists map_error.h))))
			./emap_gen$(EXE)
		else
			touch error.ml error_val.ml map_error.h

OCAMLPACKS+= bigarray unix
section
	.SCANNER: scan-c-%: map_error.h config.h
	.SCANNER: scan-ocaml-%: error.ml error_val.ml
	OCAMLFINDFLAGS+= -pp cppo
	MLFILES= uwt_base uwt_bytes
	CFILES= uwt_stubs uwt_bytes_stubs
	CFLAGS=$(CFLAGS) $(CFLAGS_LIBUV)
	LDFLAGS+=$(LDFLAGS_LIBUV)
	Repeat_targets($(MLFILES))
	UWT_BASE=$(MixedLibrary uwt_base, $(MLFILES), $(CFILES))
	lib:: $(UWT_BASE)
	export UWT_BASE

section
	MLFILES= uv_fs_sync
	OCAML_LIBS+= uwt_base
	Repeat_targets($(MLFILES))
	UV_SYNC=$(MOCamlLibrary uv_fs_sync, $(MLFILES))
	lib:: $(UV_SYNC)
	export UV_SYNC

section
	OCAMLPACKS+= lwt
	MLFILES= uwt uwt_io
	OCAML_LIBS+= uwt_base
	Repeat_targets($(MLFILES))
	UWT_CORE=$(MOCamlLibrary uwt, $(MLFILES))
	lib:: $(UWT_CORE)
	export UWT_CORE

section
	OCAMLPACKS+= lwt
	OCAML_LIBS+= uwt_base uwt
	FILES= uwt_log
	Repeat_targets($(FILES))
	UWT_LOG=$(MOCamlLibrary uwt_log, $(FILES))
	lib:: $(UWT_LOG)
	export UWT_LOG

section
	OCAMLPACKS+= lwt
	OCAML_LIBS+= uwt_base uwt uwt_log
	OCAMLFLAGS+= -thread
	FILES= uwt_preemptive
	Repeat_targets($(FILES))
	UWT_PREEMPTIVE=$(MOCamlLibrary uwt_preemptive,$(FILES))
	lib:: $(UWT_PREEMPTIVE)
	export UWT_PREEMPTIVE

section
	OCAMLPACKS+= lwt lwt.log
	OCAML_LIBS+= uwt_base uwt uwt_log
	FILES= uwt_compat
	Repeat_targets($(FILES))
	UWT_COMPAT=$(MOCamlLibrary uwt_compat,$(FILES))
	lib:: $(UWT_COMPAT)
	export UWT_COMPAT

section
	OCAMLPACKS+= lwt
	x=$(CreateDoc uwt,html,uwt_base.mli uv_sync.mli uwt_bytes.mli uwt.mli uwt_io.mli)

ConfReplace(META)
Install_helper($(PROJNAME),$(UWT_BASE) $(UV_SYNC) $(UWT_CORE) $(UWT_COMPAT) $(UWT_LOG) $(UWT_PREEMPTIVE) uwt-worker.h)

clean::
	clean-helper()
	rm -f oUnit*.log setup.data setup.log *.tar*

distclean:: clean
	rm -f *~

all:: lib
